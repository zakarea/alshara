@inproceedings{example1,
  title={An example conference paper},
  author={Bighetti, Nelson and Ford, Robert},
  booktitle={Source Themes Conference},
  pages={1--6},
  year={2013},
  organization={IEEE}
}
@conference{c1,
author={Hugo Bruneliere and Zakarea Al-Shara and Frederico Alvares and Jonathan Lejeune and Thomas Ledoux},
title={A Model-based Architecture for Autonomic and Heterogeneous Cloud Systems},
booktitle={Proceedings of the 8th International Conference on Cloud Computing and Services Science - Volume 1: CLOSER,},
year={2018},
pages={201-212},
publisher={SciTePress},
organization={INSTICC},
doi={10.5220/0006773002010212},
isbn={978-989-758-295-0},
}
@inproceedings{c2,
author = {Shatnawi, Anas and Shatnawi, Hudhaifa and Saied, Mohamed Aymen and Shara, Zakarea Al and Sahraoui, Houari and Seriai, Abdelhak},
title = {Identifying Software Components from Object-Oriented APIs Based on Dynamic Analysis},
year = {2018},
isbn = {9781450357142},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3196321.3196349},
doi = {10.1145/3196321.3196349},
abstract = {The reuse at the component level is generally more effective than the one at the object-oriented class level. This is due to the granularity level where components expose their functionalities at an abstract level compared to the fine-grained object-oriented classes. Moreover, components clearly define their dependencies through their provided and required interfaces in an explicit way that facilitates the understanding of how to reuse these components. Therefore, several component identification approaches have been proposed to identify components based on the analysis object-oriented software applications. Nevertheless, most of the existing component identification approaches did not consider co-usage dependencies between API classes to identify classes/methods that can be reused to implement a specific scenario. In this paper, we propose an approach to identify reusable software components in object-oriented APIs, based on the interactions between client applications and the targeted API. As we are dealing with actual clients using the API, dynamic analysis allows to better capture the instances of API usage. Approaches using static analysis are usually limited by the difficulty of handling dynamic features such as polymorphism and class loading. We evaluate our approach by applying it to three Java APIs with eight client applications from the DaCapo benchmark. DaCapo provides a set of pre-defined usage scenarios. The results show that our component identification approach has a very high precision.},
booktitle = {Proceedings of the 26th Conference on Program Comprehension},
pages = {189–199},
numpages = {11},
keywords = {source code, object-oriented APIs, reverse engineering, reuse, understandability, software components, dynamic analysis},
location = {Gothenburg, Sweden},
series = {ICPC '18}
}
@InProceedings{c3,
author="Alshara, Zakarea
and Seriai, Abdelhak-Djamel
and Tibermacine, Chouki
and Bouziane, Hinde Lilia
and Dony, Christophe
and Shatnawi, Anas",
editor="Tekinerdogan, Bedir
and Zdun, Uwe
and Babar, Ali",
title="Materializing Architecture Recovered from Object-Oriented Source Code in Component-Based Languages",
booktitle="Software Architecture",
year="2016",
publisher="Springer International Publishing",
address="Cham",
pages="309--325",
abstract="In the literature of software engineering, many approaches have been proposed for the recovery of software architectures. These approaches propose to group classes into highly-cohesive and loosely-coupled clusters considered as architectural components. The recovered architecture plays mainly a documentation role, as high-level design views that enhance software understandability. In addition, architecture recovery can be considered as an intermediate step for migration to component-based platforms. This migration allows to fully benefit from all advantages brought by software component concept. For that, the recovered clusters should not be considered as simple packaging and deployment units. They should be treated as real components: true structural and behavior units that are instantiable from component descriptors and connected together to materialize the architecture of the software. In this paper, we propose an approach for revealing component descriptors, component instances and component-based architecture to materialize the recovered architecture of an object-oriented software in component-based languages. We applied our solution onto two well known component-based languages, OSGi and SOFA.",
isbn="978-3-319-48992-6"
}
@InProceedings{c4,
author="Shatnawi, Anas
and Seriai, Abdelhak
and Sahraoui, Houari
and Al-Shara, Zakarea",
editor="Schaefer, Ina
and Stamelos, Ioannis",
title="Mining Software Components from Object-Oriented APIs",
booktitle="Software Reuse for Dynamic Systems in the Cloud and Beyond",
year="2014",
publisher="Springer International Publishing",
address="Cham",
pages="330--347",
abstract="Object-oriented Application Programing Interfaces (APIs) support software reuse by providing pre-implemented functionalities. Due to the huge number of included classes, reusing and understanding large APIs is a complex task. Otherwise, software components are admitted to be more reusable and understandable entities than object-oriented ones. Thus, in this paper, we propose an approach for reengineering object- oriented APIs into component-based ones. We mine components as a group of classes based on the frequency they are used together and their ability to form a quality-centric component. To validate our approach, we experimented on 100 Java applications that used Android APIs.",
isbn="978-3-319-14130-5"
}
@inproceedings{10.1145/2814204.2814223,
author = {Alshara, Zakarea and Seriai, Abdelhak-Djamel and Tibermacine, Chouki and Bouziane, Hinde Lilia and Dony, Christophe and Shatnawi, Anas},
title = {Migrating Large Object-Oriented Applications into Component-Based Ones: Instantiation and Inheritance Transformation},
year = {2015},
isbn = {9781450336871},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2814204.2814223},
doi = {10.1145/2814204.2814223},
abstract = {Large object-oriented applications have complex and numerous dependencies, and usually do not have explicit software architectures. Therefore they are hard to maintain, and parts of them are difficult to reuse. Component-based development paradigm emerged for improving these aspects and for supporting effective maintainability and reuse. It provides better understandability through a high-level architecture view of the application. Thereby migrating object-oriented applications to component-based ones will contribute to improve these characteristics (maintainability and reuse). In this paper, we propose an approach to automatically transform object-oriented applications to component-based ones. More particularly, the input of the approach is the result provided by software architecture recovery: a component-based architecture description. Then, our approach transforms the object-oriented source code in order to produce deployable components. We focus in this paper on the transformation of source code related to instantiation and inheritance dependencies between classes that are in different components. We experimented the proposed solution in the transformation of a collection of Java applications into the OSGi framework. The experimental results are discussed in this paper.},
booktitle = {Proceedings of the 2015 ACM SIGPLAN International Conference on Generative Programming: Concepts and Experiences},
pages = {55–64},
numpages = {10},
keywords = {Class Instantiation, Component, Inheritance, Encapsulation, OSGi, Java, Refactoring, Code Transformation, Object},
location = {Pittsburgh, PA, USA},
series = {GPCE 2015}
}

@article{c5,
author = {Alshara, Zakarea and Seriai, Abdelhak-Djamel and Tibermacine, Chouki and Bouziane, Hinde Lilia and Dony, Christophe and Shatnawi, Anas},
title = {Migrating Large Object-Oriented Applications into Component-Based Ones: Instantiation and Inheritance Transformation},
year = {2015},
issue_date = {March 2016},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {51},
number = {3},
issn = {0362-1340},
url = {https://doi.org/10.1145/2936314.2814223},
doi = {10.1145/2936314.2814223},
abstract = {Large object-oriented applications have complex and numerous dependencies, and usually do not have explicit software architectures. Therefore they are hard to maintain, and parts of them are difficult to reuse. Component-based development paradigm emerged for improving these aspects and for supporting effective maintainability and reuse. It provides better understandability through a high-level architecture view of the application. Thereby migrating object-oriented applications to component-based ones will contribute to improve these characteristics (maintainability and reuse). In this paper, we propose an approach to automatically transform object-oriented applications to component-based ones. More particularly, the input of the approach is the result provided by software architecture recovery: a component-based architecture description. Then, our approach transforms the object-oriented source code in order to produce deployable components. We focus in this paper on the transformation of source code related to instantiation and inheritance dependencies between classes that are in different components. We experimented the proposed solution in the transformation of a collection of Java applications into the OSGi framework. The experimental results are discussed in this paper.},
journal = {SIGPLAN Not.},
month = {oct},
pages = {55–64},
numpages = {10},
keywords = {Refactoring, Component, Object, Code Transformation, OSGi, Inheritance, Java, Encapsulation, Class Instantiation}
}




